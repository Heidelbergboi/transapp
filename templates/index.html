<!DOCTYPE html>
<html lang="sq">
<head>
  <meta charset="utf-8">
  <title>TransApp â€“ Dritare.tv</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body{background:#f8f9fa}
    .brand{color:#c41e3a;font-weight:700}
    #log{white-space:pre-wrap;font-family:monospace}
  </style>
</head>
<body class="py-5">
<div class="container">
  <h1 class="brand mb-4">TransApp</h1>

  <div class="card p-4 shadow-sm">
    <div class="mb-3">
      <input type="file" id="file" accept="video/mp4" class="form-control">
    </div>
    <div class="mb-3">
      <label class="form-label">Numri i pjesÃ«ve</label>
      <input type="number" id="parts" class="form-control" min="2" value="5">
    </div>
    <button class="btn btn-danger w-100" onclick="upload()">Starto</button>
  </div>

  <div class="progress my-3" style="height:.8rem;display:none">
    <div id="bar" class="progress-bar bg-danger" style="width:0%"></div>
  </div>

  <pre id="log" class="mt-3"></pre>
</div>

<script>
/* â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const log = t => (document.getElementById('log').textContent += t + '\n');
const bar = pct => {
  const box = document.querySelector('.progress');
  box.style.display = 'block';
  document.getElementById('bar').style.width = pct.toFixed(1) + '%';
};
const pretty = n => {
  if (n < 1024) return n + ' B';
  const u = ['KB','MB','GB','TB']; let i = -1;
  do { n /= 1024; ++i; } while (n >= 1024 && i < u.length-1);
  return n.toFixed(1) + ' ' + u[i];
};

/* â”€â”€ main orchestrator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function upload () {
  const file  = document.getElementById('file').files[0];
  const parts = document.getElementById('parts').value || 5;
  if (!file) { alert('Zgjidhni njÃ« MP4'); return; }

  /* 1) presign ------------------------------------------------ */
  log('ðŸš¦ /sign â€¦');
  const sign = await fetch('/sign', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ filename:file.name, size:file.size })
      }).then(r=>r.json());

  /* 2) upload ------------------------------------------------- */
  if (sign.multipart) {
    await uploadMultipart(file, sign);          // >100 MB
  } else {
    await uploadSinglePost(file, sign);         // â‰¤100 MB
  }

  /* 3) kick off server job ----------------------------------- */
  log('ðŸš¦ /start-job â€¦');
  const j = await fetch('/start-job', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ s3_key: sign.s3_key, parts })
      }).then(r=>r.json());

  window.location = j.stream;
}

/* â”€â”€ single POST (â‰¤100 MB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function uploadSinglePost (file, sign) {
  const fd = new FormData();
  Object.entries(sign.fields).forEach(([k,v])=>fd.append(k,v));
  fd.append('file', file);

  log(`â¬†ï¸  Uploading ${pretty(file.size)} (single POST)â€¦`);
  await new Promise((resolve, reject) => {
    const x = new XMLHttpRequest();
    x.open('POST', sign.url, true);
    x.upload.onprogress = e => {
      if (e.lengthComputable) bar(e.loaded/e.total*100);
    };
    x.onload  = () => x.status===204 ? resolve() : reject('S3 '+x.status);
    x.onerror = () => reject('network/CORS error');
    x.send(fd);
  });
  bar(100); log('âœ… Upload complete');
}

/* â”€â”€ multipart PUT (>100 MB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function uploadMultipart (file, meta) {
  const { part_urls, complete_url, part_mb } = meta;
  const partSize   = part_mb * 1024 * 1024;
  const etags      = Array(part_urls.length);
  const totalParts = part_urls.length;
  const maxParallel= 5;                               // batch size
  let   doneParts  = 0;

  log(`â¬†ï¸  Multipart ${totalParts}Ã—${part_mb} MBâ€¦`);
  const putPart = async (i) => {
    const start = i * partSize;
    const blob  = file.slice(start, Math.min(start+partSize, file.size));
    const r     = await fetch(part_urls[i], {method:'PUT', body:blob});
    if(!r.ok) throw new Error('part '+(i+1)+' failed');
    etags[i] = {ETag:r.headers.get('ETag'), PartNumber:i+1};
    doneParts++;
    bar(doneParts/totalParts*100);
    log('   âœ… part '+(i+1)+'/'+totalParts);
  };

  // queue with limited concurrency
  const queue = Array.from({length:totalParts}, (_,i)=>i);
  const workers = Array.from({length:Math.min(maxParallel,totalParts)}, async()=> {
    while (queue.length) await putPart(queue.shift());
  });
  await Promise.all(workers);

  /* 3) complete upload */
  const body = `<CompleteMultipartUpload>${
        etags.map(e=>`<Part><ETag>${e.ETag}</ETag><PartNumber>${e.PartNumber}</PartNumber></Part>`).join('')
      }</CompleteMultipartUpload>`;
  const done = await fetch(complete_url, {
        method:'POST',
        headers:{'Content-Type':'application/xml'},
        body
      });
  if(!done.ok) throw new Error('complete failed');
  bar(100); log('âœ… Upload complete');
}
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
