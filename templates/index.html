<!DOCTYPE html>
<html lang="sq">
<head>
  <meta charset="utf-8">
  <title>TransApp â€“ Dritare.tv</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body{background:#f8f9fa}
    .brand{color:#c41e3a;font-weight:700}
    #log{white-space:pre-wrap;font-family:monospace}
  </style>
</head>
<body class="py-5">
<div class="container">
  <h1 class="brand mb-4">TransApp</h1>

  <div class="card p-4 shadow-sm">
    <div class="mb-3">
      <input type="file" id="file" accept="video/mp4" class="form-control">
    </div>
    <div class="mb-3">
      <label class="form-label">Numri i pjesÃ«ve</label>
      <input type="number" id="parts" class="form-control" min="2" value="5">
    </div>
    <button class="btn btn-danger w-100" onclick="upload()">Starto</button>
  </div>

  <pre id="log" class="mt-4"></pre>
</div>

<script>
/* â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const log = t => (document.getElementById('log').textContent += t + '\n');
const pretty = n => {
  if (n < 1024) return n + ' B';
  const units = ['KB','MB','GB','TB']; let i = -1;
  do { n /= 1024; ++i; } while (n >= 1024 && i < units.length-1);
  return n.toFixed(1) + ' ' + units[i];
};

/* â”€â”€ main orchestrator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function upload () {
  const file  = document.getElementById('file').files[0];
  const parts = document.getElementById('parts').value || 5;
  if (!file) { alert('Zgjidhni njÃ« MP4'); return; }

  /* 1) presign ---------------------------------------------------- */
  log('ðŸš¦ /sign â€¦');
  const sign = await fetch('/sign', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ filename:file.name, size:file.size })
      }).then(r=>r.json());

  /* 2) upload ----------------------------------------------------- */
  if (sign.multipart) {
    await uploadMultipart(file, sign);
  } else {
    await uploadSinglePost(file, sign);
  }

  /* 3) fire the back-end job -------------------------------------- */
  log('ðŸš¦ /start-job â€¦');
  const j = await fetch('/start-job', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({ s3_key: sign.s3_key, parts })
      }).then(r=>r.json());

  window.location = j.stream;
}

/* â”€â”€ single POST (â‰¤100 MB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function uploadSinglePost (file, sign) {
  const fd = new FormData();
  Object.entries(sign.fields).forEach(([k,v])=>fd.append(k,v));
  fd.append('file', file);

  log(`â¬†ï¸  Uploading ${pretty(file.size)} to S3 (single POST)â€¦`);
  await new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', sign.url, true);
    xhr.upload.onprogress = ev => {
      if (!ev.lengthComputable) return;
      const pct = (ev.loaded / ev.total * 100).toFixed(1);
      log(`   â€¦ ${pct}% (${pretty(ev.loaded)} / ${pretty(ev.total)})`);
    };
    xhr.onload  = () => xhr.status === 204 ? resolve()
                                          : reject(new Error('S3 POST failed'));
    xhr.onerror = () => reject(new Error('network error during S3 POST'));
    xhr.send(fd);
  });
  log('âœ… Upload complete');
}

/* â”€â”€ multipart PUT (>100 MB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function uploadMultipart (file, meta) {
  const { part_urls, complete_url, part_mb } = meta;
  const partSize = part_mb * 1024 * 1024;
  const etags = Array(part_urls.length);

  log(`â¬†ï¸  Multipart upload ${part_urls.length}Ã—${part_mb} MBâ€¦`);

  await Promise.all(part_urls.map((url,i)=> (async()=>{
    const start = i * partSize;
    const blob  = file.slice(start, Math.min(start+partSize, file.size));
    const r     = await fetch(url, {method:'PUT', body:blob});
    if(!r.ok) throw new Error('part '+(i+1)+' failed');
    etags[i] = {ETag:r.headers.get('ETag'), PartNumber:i+1};
    log(`   â€¦ part ${i+1}/${part_urls.length} ok`);
  })()));

  /* complete */
  const body = `<CompleteMultipartUpload>${
      etags.map(e=>`<Part><ETag>${e.ETag}</ETag><PartNumber>${e.PartNumber}</PartNumber></Part>`).join('')
    }</CompleteMultipartUpload>`;

  const done = await fetch(complete_url, {
        method:'POST',
        headers:{'Content-Type':'application/xml'},
        body
      });
  if(!done.ok) throw new Error('complete failed');
  log('âœ… Upload complete');
}
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
